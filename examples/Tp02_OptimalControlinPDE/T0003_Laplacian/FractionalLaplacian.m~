N = 20;
s = 0.8;
xi = -1; xf = 1;
xline = linspace(xi,xf,N);
a = -0.3; b = 0.5;

symY = SymsVector('y',N);
symU = SymsVector('u',N);
%% Creamos Funcional


%% Creamos el ODE 
%%%%%%%%%%%%%%%%

Y0 = 2+2*cos(pi*xline)';
%%%%%%%%%%%%%%%%

%rho = 1000;
A = -FEFractionalLaplacian(s,1,N);
%%%%%%%%%%%%%%%%  
B = construction_matrix_B(xline,a,b);
%%%%%%%%%%%%%%%%
Fsym  = A*symY + B*symU;
%%%%%%%%%%%%%%%%
T = 5;
odeEqn = ode('A',A,'B',B,'Condition',Y0,'FinalTime',T);


%% Veamos que queremos 

solve(odeEqn)

line(xline,YT,'Color','red')
line(xline,odeEqn.VectorState.Numeric(end,:),'Color','blue')
legend('Target','Free Dynamics')

%% Creamos Problema de Control

YT = 0.0*sin(pi*xline)';

symPsi  = (YT - symY).'*(YT - symY);
symL    = 0.001*(symU.'*symU);
iCP1 = OptimalControl(odeEqn,symPsi,symL);

%% Solve Gradient
tol = 1.0;
DescentParameters = {'InitialLengthStep',5.0};

%
GradientMethod(iCP1,'tol',tol,'DescentParameters',DescentParameters,'graphs',true,'TypeGraph')
% Several ways to run
% GradientMethod(iCP1)
% GradientMethod(iCP1,'DescentParameters',DescentParameters)
% GradientMethod(iCP1,'DescentParameters',DescentParameters,'graphs',true)

% iCP1.ode
function [B] = construction_matrix_B(mesh,a,b)

N = length(mesh);
B = zeros(N,N);

control = (mesh>=a).*(mesh<=b);
B = diag(control);

end
