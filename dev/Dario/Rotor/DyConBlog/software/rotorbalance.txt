#parameters for the algorithm execution.
param pi = 4*atan(1);
param Nt = 1000;
param T = 120;
param dt = T/(Nt);

#physical parameters.
param m1 = 1;
param m2 = 1;
param a = 1;
param b = 1;
param r1 = 1;
param r2 = 1;
param omega = 2000*(2*pi)/60;
param Fx = -2*m1*r1*omega^2;
param Fy = -2*m2*r2*omega^2;
param Nx = 0;
param Ny = 0;
param F1x = (b*Fx-Ny)/(a+b);
param F1y = (b*Fy+Nx)/(a+b);
param F2x = (a*Fx+Ny)/(a+b);
param F2y = (a*Fy-Nx)/(a+b);
#param ss = [0;pi;0;pi];
#WARNING:
#The condition below must be fulfilled.
#m_1r_1 > \frac{\sqrt{F_{1,x}^2+F_{1,y}^2}}{2\omega^2}\hspace{0.3 cm}\mbox{and}\hspace{0.3 cm}m_2r_2> \frac{\sqrt{F_{2,x}^2+F_{2,y}^2}}{2\omega^2},

#weighting parameters.
param beta = 0.25*(2*omega^2)^(-2); #omega^4*(1000/120);

var Phi {i in 0..Nt, j in 1..4};  # Phi(t), state
var psi {i in 0..Nt-1, j in 1..4}; # psi(t), control, default 0;

#CHECK cost.
minimize cost: sum {i in 0..Nt-1} (0.5*dt*(psi[i,1]^2+psi[i,2]^2+psi[i,3]^2+psi[i,4]^2)+(beta/(2))*dt*((2*m1*r1*omega^2*cos(Phi[i,2])*cos(Phi[i,1])+F1x)^2+(2*m1*r1*omega^2*cos(Phi[i,2])*sin(Phi[i,1])+F1y)^2)+(beta/(2))*dt*((2*m2*r2*omega^2*cos(Phi[i,4])*cos(Phi[i,3])+F2x)^2+(2*m2*r2*omega^2*cos(Phi[i,4])*sin(Phi[i,3])+F2y)^2));

subject to Phi_dyn_one {i in 1..Nt}:
	((Phi[i,1]-Phi[i-1,1])/(dt)) = psi[i-1,1];
subject to Phi_dyn_two {i in 1..Nt}:
	((Phi[i,2]-Phi[i-1,2])/(dt)) = psi[i-1,2];
subject to Phi_dyn_three {i in 1..Nt}:
	((Phi[i,3]-Phi[i-1,3])/(dt)) = psi[i-1,3];
subject to Phi_dyn_four {i in 1..Nt}:
	((Phi[i,4]-Phi[i-1,4])/(dt)) = psi[i-1,4];

subject to initial_condition_one: Phi[0,1] = 0; #1;
subject to initial_condition_two: Phi[0,2] = pi; #0.3;
subject to initial_condition_three: Phi[0,3] = 0; #0.6;
subject to initial_condition_four: Phi[0,4] = pi; #0.3;

option solver ipopt;
option ipopt_options "max_iter=2000 linear_solver=mumps halt_on_ampl_error yes";
solve;


printf: " # cost = %24.16e\n", cost; # > out_MMarposs1.txt;
printf: " # T = %24.16e\n", T; # > out_MMarposs1.txt;
printf: " # Nt = %d\n", Nt; # >> out_MMarposs1.txt;
printf: " # Data\n"; # >> out_MMarposs1.txt;
printf {i in 0..Nt}: " %24.16e\n", Phi[i,1]; # >> out_rotorbalance.txt;
printf {i in 0..Nt}: " %24.16e\n", Phi[i,2]; # >> out_rotorbalance.txt;
printf {i in 0..Nt}: " %24.16e\n", Phi[i,3]; # >> out_rotorbalance.txt;
printf {i in 0..Nt}: " %24.16e\n", Phi[i,4]; # >> out_rotorbalance.txt;
printf: " # Imbalance indicator evaluated at (Phi[Nt,1],Phi[Nt,2],Phi[Nt,3],Phi[Nt,4])\n"; # > out_rotorbalance.txt;
printf: " %24.16e\n", ((2*m1*r1*omega^2*cos(Phi[Nt,2])*cos(Phi[Nt,1])+F1x)^2+(2*m1*r1*omega^2*cos(Phi[Nt,2])*sin(Phi[Nt,1])+F1y)^2)+((2*m2*r2*omega^2*cos(Phi[Nt,4])*cos(Phi[Nt,3])+F2x)^2+(2*m2*r2*omega^2*cos(Phi[Nt,4])*sin(Phi[Nt,3])+F2y)^2); # >> out_rotorbalance.txt;



end;
